<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>ì •ë¥˜ì¥ ìˆœì„œ ìˆ˜ì • - ë°©í–¥ ë¶„ë¦¬</title>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
    <style>
        table {
            width: 45%;
            margin-bottom: 30px;
            border-collapse: collapse;
        }

        table, th, td {
            border: 1px solid #aaa;
        }

        th {
            background-color: #f0f0f0;
        }

        .dragging {
            background-color: #e0ffff;
        }

        .table-group {
            display: flex;
            flex-direction: column; /* âœ… ìœ„ì•„ë˜ë¡œ ì •ë ¬ */
            gap: 2rem;
        }

        .non-draggable {
            background-color: #fdf3c1; /* ê°•ì¡°ìš© */
            cursor: not-allowed;
        }
    </style>
</head>
<body>

<h1>ğŸšŒ ë…¸ì„  ì •ë¥˜ì¥ ìˆœì„œ ìˆ˜ì • (ì •/ì—­ë°©í–¥ ë¶„ë¦¬)</h1>

<label>ë…¸ì„  ID: <input type="text" id="routeIdInput"></label>
<button onclick="loadStops()">ë¶ˆëŸ¬ì˜¤ê¸°</button>

<hr>

<div class="table-group">
    <!-- ì •ë°©í–¥ -->
    <form id="formForward">
        <h2>ì •ë°©í–¥</h2>
        <table>
            <thead>
            <tr>
                <th>ì •ë¥˜ì†Œ ID</th>
                <th>ì •ë¥˜ì†Œ ì´ë¦„</th>
                <th>ìˆœì„œ</th>
            </tr>
            </thead>
            <tbody id="forwardBody"></tbody>
        </table>
    </form>

    <!-- ì—­ë°©í–¥ -->
    <form id="formBackward">
        <h2>ì—­ë°©í–¥</h2>
        <table>
            <thead>
            <tr>
                <th>ì •ë¥˜ì†Œ ID</th>
                <th>ì •ë¥˜ì†Œ ì´ë¦„</th>
                <th>ìˆœì„œ</th>
            </tr>
            </thead>
            <tbody id="backwardBody"></tbody>
        </table>
    </form>
</div>

<button onclick="submitAll()">ğŸ’¾ ìˆœì„œ ì €ì¥</button>

<script>let forwardSortable, backwardSortable;

async function loadStops() {
    const routeId = document.getElementById('routeIdInput').value.trim();
    if (!routeId) {
        alert('ë…¸ì„  IDë¥¼ ì…ë ¥í•˜ì„¸ìš”.');
        return;
    }

    const res = await fetch(`/api/bus/bus-route?routeId=${routeId}`);
    if (!res.ok) {
        alert('ë…¸ì„  ì •ë³´ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
        return;
    }

    const data = await res.json();

    const forwardBody = document.getElementById('forwardBody');
    const backwardBody = document.getElementById('backwardBody');
    forwardBody.innerHTML = "";
    backwardBody.innerHTML = "";

    // ë¶„ë¦¬ ì¶œë ¥
    data.forEach((stop, idx) => {
        const row = document.createElement('tr');
        row.innerHTML = `
            <td><input type="text" name="bsId" value="${stop.bsId}" readonly></td>
            <td>${stop.bsNm || '-'}</td>
            <td class="seq-cell">${stop.seq}</td>
            <input type="hidden" name="moveDir" value="${stop.moveDir}">
        `;

        if (stop.moveDir === "1") forwardBody.appendChild(row);
        else backwardBody.appendChild(row);
    });

    // ì¶œë„ì°©ì§€ì— ë“œë˜ê·¸ ë§‰ëŠ” í´ë˜ìŠ¤ ì¶”ê°€
    const applyNonDraggable = (tbody) => {
        const rows = tbody.querySelectorAll("tr");
        if (rows.length > 0) {
            rows[0].classList.add("non-draggable"); // ì¶œë°œì§€
            rows[rows.length - 1].classList.add("non-draggable"); // ë„ì°©ì§€
        }
    };
    applyNonDraggable(forwardBody);
    applyNonDraggable(backwardBody);

    // ê³µí†µ ë“œë˜ê·¸ ì˜µì…˜
    const createSortable = (tbody) => Sortable.create(tbody, {
        animation: 150,
        ghostClass: 'dragging',
        filter: ".non-draggable",
        preventOnFilter: false,
        onMove: function (evt) {
            const dragged = evt.dragged;
            const target = evt.related;

            // ë“œë˜ê·¸ ìì²´ê°€ ì¶œë„ì°©ì§€ â†’ ë§‰ìŒ
            if (dragged.classList.contains("non-draggable")) return false;

            // íƒ€ê²Ÿ ìœ„ì¹˜ê°€ ì¶œë„ì°©ì§€ â†’ ë§‰ìŒ
            if (target.classList.contains("non-draggable")) return false;

            return true;
        },
        onEnd: updateSeqs
    });

    // Sortable ì´ˆê¸°í™”
    if (forwardSortable) forwardSortable.destroy();
    forwardSortable = createSortable(forwardBody);

    if (backwardSortable) backwardSortable.destroy();
    backwardSortable = createSortable(backwardBody);

    updateSeqs();
}

function updateSeqs() {
    const update = (rows) => {
        rows.forEach((row, idx) => {
            row.querySelector(".seq-cell").textContent = idx + 1;
        });
    };
    update(document.querySelectorAll("#forwardBody tr"));
    update(document.querySelectorAll("#backwardBody tr"));
}

async function submitAll() {
    const routeId = document.getElementById('routeIdInput').value.trim();
    if (!routeId) return alert("ë…¸ì„  IDê°€ ì—†ìŠµë‹ˆë‹¤.");

    const collectData = (tbody) =>
        Array.from(tbody.querySelectorAll("tr")).map((row, idx) => ({
            routeId,
            bsId: row.querySelector('[name="bsId"]').value,
            moveDir: row.querySelector('[name="moveDir"]').value,
            seq: idx + 1
        }));

    const payload = [
        ...collectData(document.getElementById("forwardBody")),
        ...collectData(document.getElementById("backwardBody"))
    ];

    const res = await fetch('/api/bus/UpdateRouteLink', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
    });

    if (res.ok) {
        alert("âœ… ìˆœì„œê°€ ì„±ê³µì ìœ¼ë¡œ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!");
    } else {
        alert("âŒ ìˆœì„œ ì €ì¥ ì‹¤íŒ¨");
    }
}

</script>

</body>
</html>
